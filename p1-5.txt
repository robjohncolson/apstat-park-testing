Phase 1.5: Implementing the Validation Logic (validation.ts)
Goal: Implement the set of pure functions that act as the "rulebook" for the entire blockchain. This is the most critical logic phase.
Key Actions:
This file will contain functions that take data objects and the database instance as arguments and return true or false.
Implement isTransactionValid(tx: Transaction): boolean. This will use crypto.verify to check the signature.
Implement isBlockValid(block: Block, db: ChainDB): Promise<boolean>. This is the master validation function, which will call several smaller helper functions:
isBlockHashCorrect(block): Re-hashes the header to check its integrity.
isMerkleRootCorrect(block): Re-calculates the Merkle root from the transactions and compares it.
isProofOfAccessValid(block, db): Uses the db instance to check that the proofOfAccessHash in the header points to a real, historical transaction for that user.
areAllTransactionsValid(block): Loops through transactions and calls isTransactionValid.
Create Unit Tests: Create validation.test.ts. This is essential.
Create mock Block and Transaction objects.
For each validation rule, write at least two tests: one with valid data that should pass, and one with invalid data (e.g., a tampered signature) that should fail.
Clarifying Question for This Implementation Strategy:
The plan defers the consensus.ts (Proof of Knowledge logic) and QuizBank.ts to be implemented after this core foundation is complete. Is this sequence acceptable? My reasoning is that the core rules of what makes a block valid (validation.ts) should be built before we build the logic that creates new blocks (consensus.ts). This ensures we build on a solid, testable foundation.

**Note: PATH variable is broken.  Prefix NPM commands with run.bat which is at root of project.  ie.  cd apps/web; ../../run.bat npm run dev